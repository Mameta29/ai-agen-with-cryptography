// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{POLICY_VERIFIER_ELF, POLICY_VERIFIER_ID};
use risc0_zkvm::{default_prover, ExecutorEnv, Receipt};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

// Re-export the types from guest for consistency
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PaymentIntent {
    pub amount: u64,
    pub recipient: String,
    pub timestamp: u64,
    pub vendor: String,
    pub category: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PolicyRules {
    pub max_per_payment: u64,
    pub max_per_day: u64,
    pub max_per_week: u64,
    pub allowed_vendors: Vec<String>,
    pub allowed_hours_start: u8,
    pub allowed_hours_end: u8,
    pub allowed_weekdays: Vec<u8>,
    pub blocked_keywords: Vec<String>,
    pub custom_rules: HashMap<String, serde_json::Value>,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct PolicyEvaluation {
    pub approved: bool,
    pub reason: String,
    pub risk_score: u8,
    pub violations: Vec<String>,
    pub policy_hash: [u8; 32],
}

#[derive(Serialize, Deserialize, Debug)]
pub struct ZkVMInput {
    pub intent: PaymentIntent,
    pub policy: PolicyRules,
    pub current_spending: u64,
    pub weekly_spending: u64,
}

pub struct ZkVMPolicyEngine;

impl ZkVMPolicyEngine {
    pub fn new() -> Self {
        ZkVMPolicyEngine
    }

    pub fn prove_policy_compliance(
        &self,
        intent: PaymentIntent,
        policy: PolicyRules,
        current_spending: u64,
        weekly_spending: u64,
    ) -> Result<(PolicyEvaluation, Receipt), Box<dyn std::error::Error>> {
        // Initialize tracing
        tracing_subscriber::fmt()
            .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
            .init();

        let input = ZkVMInput {
            intent,
            policy,
            current_spending,
            weekly_spending,
        };

        // Create executor environment with our input
        let env = ExecutorEnv::builder()
            .write(&input)?
            .build()?;

        // Get the default prover
        let prover = default_prover();

        println!("ðŸ” Generating ZK proof for policy compliance...");
        let start_time = std::time::Instant::now();

        // Generate the proof
        let prove_info = prover.prove(env, POLICY_VERIFIER_ELF)?;
        let receipt = prove_info.receipt;

        let duration = start_time.elapsed();
        println!("âœ… ZK proof generated in {:?}", duration);

        // Decode the output
        let evaluation: PolicyEvaluation = receipt.journal.decode()?;

        // Verify the receipt
        receipt.verify(POLICY_VERIFIER_ID)?;
        println!("ðŸ” ZK proof verified successfully");

        Ok((evaluation, receipt))
    }

    pub fn verify_receipt(receipt: &Receipt) -> Result<PolicyEvaluation, Box<dyn std::error::Error>> {
        // Verify the receipt
        receipt.verify(POLICY_VERIFIER_ID)?;
        
        // Decode and return the evaluation
        let evaluation: PolicyEvaluation = receipt.journal.decode()?;
        Ok(evaluation)
    }
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Example usage
    let engine = ZkVMPolicyEngine::new();

    // Create a sample payment intent
    let intent = PaymentIntent {
        amount: 50000, // 50,000 JPY
        recipient: "0x1234567890123456789012345678901234567890".to_string(),
        timestamp: 1704067200, // 2024-01-01 00:00:00 UTC
        vendor: "Sample Vendor Corp".to_string(),
        category: "utilities".to_string(),
    };

    // Create a sample policy
    let mut custom_rules = HashMap::new();
    custom_rules.insert("utilities".to_string(), serde_json::Value::Number(serde_json::Number::from(100000)));

    let policy = PolicyRules {
        max_per_payment: 100000,
        max_per_day: 300000,
        max_per_week: 1000000,
        allowed_vendors: vec![
            "Sample Vendor Corp".to_string(),
            "Trusted Partner Inc".to_string(),
        ],
        allowed_hours_start: 9,
        allowed_hours_end: 18,
        allowed_weekdays: vec![1, 2, 3, 4, 5], // Monday to Friday
        blocked_keywords: vec!["suspicious".to_string(), "scam".to_string()],
        custom_rules,
    };

    // Generate proof
    let (evaluation, _receipt) = engine.prove_policy_compliance(
        intent,
        policy,
        25000, // Current daily spending
        150000, // Current weekly spending
    )?;

    println!("\nðŸ“Š Policy Evaluation Result:");
    println!("âœ… Approved: {}", evaluation.approved);
    println!("ðŸ“ Reason: {}", evaluation.reason);
    println!("âš ï¸  Risk Score: {}/100", evaluation.risk_score);
    println!("ðŸ”’ Policy Hash: {:?}", hex::encode(evaluation.policy_hash));

    if !evaluation.violations.is_empty() {
        println!("âŒ Violations:");
        for violation in &evaluation.violations {
            println!("   - {}", violation);
        }
    }

    Ok(())
}

// Helper function to convert bytes to hex string
mod hex {
    pub fn encode(bytes: [u8; 32]) -> String {
        bytes.iter()
            .map(|b| format!("{:02x}", b))
            .collect::<Vec<String>>()
            .join("")
    }
}
