// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{POLICY_VERIFIER_ELF, POLICY_VERIFIER_ID};
use risc0_zkvm::{default_prover, ExecutorEnv, Receipt};
use std::collections::hash_map::DefaultHasher;
use std::hash::{Hash, Hasher};

// ç°¡ç•¥åŒ–ã•ã‚ŒãŸæ§‹é€ ä½“
#[derive(Clone, Debug)]
pub struct PaymentIntent {
    pub amount: u64,
    pub recipient: String,
    pub timestamp: u64,
    pub vendor: String,
}

#[derive(Clone, Debug)]
pub struct PolicyRules {
    pub max_per_payment: u64,
    pub max_per_day: u64,
    pub max_per_week: u64,
    pub allowed_vendors: Vec<String>,
    pub allowed_hours_start: u8,
    pub allowed_hours_end: u8,
    pub allowed_weekdays: Vec<u8>,
}

#[derive(Debug)]
pub struct PolicyEvaluation {
    pub approved: bool,
    pub risk_score: u8,
    pub violation_count: u8,
}

pub struct ZkVMPolicyEngine;

impl ZkVMPolicyEngine {
    pub fn new() -> Self {
        ZkVMPolicyEngine
    }

    pub fn prove_policy_compliance(
        &self,
        intent: PaymentIntent,
        policy: PolicyRules,
        current_spending: u64,
        weekly_spending: u64,
    ) -> Result<(PolicyEvaluation, Receipt), Box<dyn std::error::Error>> {
        // Initialize tracing
        tracing_subscriber::fmt()
            .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
            .init();

        // æ–‡å­—åˆ—ã‚’ãƒãƒƒã‚·ãƒ¥ã«å¤‰æ›
        let recipient_hash = self.hash_string(&intent.recipient);
        let vendor_hash = self.hash_string(&intent.vendor);
        let allowed_vendor_hash = if !policy.allowed_vendors.is_empty() {
            self.hash_string(&policy.allowed_vendors[0])
        } else {
            0
        };

        // æ›œæ—¥ã‚’ãƒ“ãƒƒãƒˆãƒã‚¹ã‚¯ã«å¤‰æ›
        let mut weekday_mask = 0u8;
        for &day in &policy.allowed_weekdays {
            if day < 8 {
                weekday_mask |= 1u8 << day;
            }
        }

        // Create executor environment with individual inputs
        let env = ExecutorEnv::builder()
            .write(&intent.amount)?
            .write(&recipient_hash)?
            .write(&intent.timestamp)?
            .write(&vendor_hash)?
            .write(&policy.max_per_payment)?
            .write(&policy.max_per_day)?
            .write(&policy.max_per_week)?
            .write(&allowed_vendor_hash)?
            .write(&policy.allowed_hours_start)?
            .write(&policy.allowed_hours_end)?
            .write(&weekday_mask)?
            .write(&current_spending)?
            .write(&weekly_spending)?
            .build()?;

        // Get the default prover
        let prover = default_prover();

        println!("ğŸ” Generating ZK proof for policy compliance...");
        let start_time = std::time::Instant::now();

        // Generate the proof
        let prove_info = prover.prove(env, POLICY_VERIFIER_ELF)?;
        let receipt = prove_info.receipt;

        let duration = start_time.elapsed();
        println!("âœ… ZK proof generated in {:?}", duration);

        // Decode the outputs (3 separate values)
        let approved: u8 = receipt.journal.decode()?;
        let risk_score: u8 = receipt.journal.decode()?;
        let violation_count: u8 = receipt.journal.decode()?;

        let evaluation = PolicyEvaluation {
            approved: approved != 0,
            risk_score,
            violation_count,
        };

        // Verify the receipt
        receipt.verify(POLICY_VERIFIER_ID)?;
        println!("ğŸ” ZK proof verified successfully");

        Ok((evaluation, receipt))
    }

    pub fn verify_receipt(receipt: &Receipt) -> Result<PolicyEvaluation, Box<dyn std::error::Error>> {
        // Verify the receipt
        receipt.verify(POLICY_VERIFIER_ID)?;
        
        // Decode the outputs
        let approved: u8 = receipt.journal.decode()?;
        let risk_score: u8 = receipt.journal.decode()?;
        let violation_count: u8 = receipt.journal.decode()?;

        let evaluation = PolicyEvaluation {
            approved: approved != 0,
            risk_score,
            violation_count,
        };

        Ok(evaluation)
    }

    // æ–‡å­—åˆ—ã‚’u64ãƒãƒƒã‚·ãƒ¥ã«å¤‰æ›
    fn hash_string(&self, s: &str) -> u64 {
        let mut hasher = DefaultHasher::new();
        s.hash(&mut hasher);
        hasher.finish()
    }
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Example usage
    let engine = ZkVMPolicyEngine::new();

    // Create a sample payment intent
    let intent = PaymentIntent {
        amount: 50000, // 50,000 JPY
        recipient: "0x1234567890123456789012345678901234567890".to_string(),
        timestamp: 1704067200, // 2024-01-01 00:00:00 UTC
        vendor: "Sample Vendor Corp".to_string(),
    };

    // Create a sample policy
    let policy = PolicyRules {
        max_per_payment: 100000,
        max_per_day: 300000,
        max_per_week: 1000000,
        allowed_vendors: vec![
            "Sample Vendor Corp".to_string(),
            "Trusted Partner Inc".to_string(),
        ],
        allowed_hours_start: 9,
        allowed_hours_end: 18,
        allowed_weekdays: vec![1, 2, 3, 4, 5], // Monday to Friday
    };

    // Generate proof
    let (evaluation, _receipt) = engine.prove_policy_compliance(
        intent,
        policy,
        25000, // Current daily spending
        150000, // Current weekly spending
    )?;

    println!("\nğŸ“Š Policy Evaluation Result:");
    println!("âœ… Approved: {}", evaluation.approved);
    println!("âš ï¸  Risk Score: {}/100", evaluation.risk_score);
    println!("âŒ Violations: {}", evaluation.violation_count);

    Ok(())
}
